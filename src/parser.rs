pub enum Keys {
    A = 0x1E,
    B = 0x30,
    C = 0x2E,
    D = 0x20,
    E = 0x12,
    F = 0x21,
    G = 0x22,
    H = 0x23,
    I = 0x17,
    J = 0x24,
    K = 0x25,
    L = 0x26,
    M = 0x32,
    N = 0x31,
    O = 0x18,
    P = 0x19,
    Q = 0x10,
    R = 0x13,
    S = 0x1F,
    T = 0x14,
    U = 0x16,
    V = 0x2F,
    W = 0x11,
    X = 0x2D,
    Y = 0x15,
    Z = 0x2C,
    BackTick = 0x29,
    Num0 = 0x0B,
    Num1 = 0x02,
    Num2 = 0x03,
    Num3 = 0x04,
    Num4 = 0x05,
    Num5 = 0x06,
    Num6 = 0x07,
    Num7 = 0x08,
    Num8 = 0x09,
    Num9 = 0x0A,
    Escape = 0x01,
    F1 = 0x3B,
    F2 = 0x3C,
    F3 = 0x3D,
    F4 = 0x3E,
    F5 = 0x3F,
    F6 = 0x40,
    F7 = 0x41,
    F8 = 0x42,
    F9 = 0x43,
    F10 = 0x44,
    F11 = 0x57,
    F12 = 0x58,
    LeftCtrl = 0x1D,
    LeftShift = 0x2A,
    LeftMod = 0x7D,
    LeftAlt = 0x38,
    RightCtrl = 0x61,
    RightShift = 0x36,
    RightMod = 0x7e,
    RightAlt = 0x64,
    Space = 0x39,
    Enter = 0x1C,
    Backspace = 0x0E,
    Tab = 0x0F,
    Up = 0xC8,
    Down = 0xD0,
    Left = 0xCB,
    Right = 0xCD,
    Insert = 0xD2,
    Delete = 0xD3,
    Home = 0xC7,
    End = 0xCF,
    PageUp = 0xC9,
    PageDown = 0xD1,
    Comma = 0x33,
    Period = 0x34,
    Slash = 0x35,
    LeftSquare = 0x1a,
    RightSquare = 0x1b,
    SemiColon = 0x27,
    Quote = 0x28,
    BackSlash = 0x2b,
    Dash = 0x0c,
    Equal = 0x0d,
    }

pub fn parse_binding(binding: &str) -> Vec<u32> {
    let strings: Vec<String> = binding.split('+').map(|s| s.to_string()).collect();

    let mut keys = Vec::new();
    for string in strings {
        match string.as_str() {
            "A" => keys.push(Keys::A as u32),
            "B" => keys.push(Keys::B as u32),
            "C" => keys.push(Keys::C as u32),
            "D" => keys.push(Keys::D as u32),
            "E" => keys.push(Keys::E as u32),
            "F" => keys.push(Keys::F as u32),
            "G" => keys.push(Keys::G as u32),
            "H" => keys.push(Keys::H as u32),
            "I" => keys.push(Keys::I as u32),
            "J" => keys.push(Keys::J as u32),
            "K" => keys.push(Keys::K as u32),
            "L" => keys.push(Keys::L as u32),
            "M" => keys.push(Keys::M as u32),
            "N" => keys.push(Keys::N as u32),
            "O" => keys.push(Keys::O as u32),
            "P" => keys.push(Keys::P as u32),
            "Q" => keys.push(Keys::Q as u32),
            "R" => keys.push(Keys::R as u32),
            "S" => keys.push(Keys::S as u32),
            "T" => keys.push(Keys::T as u32),
            "U" => keys.push(Keys::U as u32),
            "V" => keys.push(Keys::V as u32),
            "W" => keys.push(Keys::W as u32),
            "X" => keys.push(Keys::X as u32),
            "Y" => keys.push(Keys::Y as u32),
            "Z" => keys.push(Keys::Z as u32),
            "0" => keys.push(Keys::Num0 as u32),
            "1" => keys.push(Keys::Num1 as u32),
            "2" => keys.push(Keys::Num2 as u32),
            "3" => keys.push(Keys::Num3 as u32),
            "4" => keys.push(Keys::Num4 as u32),
            "5" => keys.push(Keys::Num5 as u32),
            "6" => keys.push(Keys::Num6 as u32),
            "7" => keys.push(Keys::Num7 as u32),
            "8" => keys.push(Keys::Num8 as u32),
            "9" => keys.push(Keys::Num9 as u32),
            "BackTick" => keys.push(Keys::BackTick as u32),
            "Escape" => keys.push(Keys::Escape as u32),
            "F1" => keys.push(Keys::F1 as u32),
            "F2" => keys.push(Keys::F2 as u32),
            "F3" => keys.push(Keys::F3 as u32),
            "F4" => keys.push(Keys::F4 as u32),
            "F5" => keys.push(Keys::F5 as u32),
            "F6" => keys.push(Keys::F6 as u32),
            "F7" => keys.push(Keys::F7 as u32),
            "F8" => keys.push(Keys::F8 as u32),
            "F9" => keys.push(Keys::F9 as u32),
            "F10" => keys.push(Keys::F10 as u32),
            "F11" => keys.push(Keys::F11 as u32),
            "F12" => keys.push(Keys::F12 as u32),
            "LeftAlt" => keys.push(Keys::LeftAlt as u32),
            "LeftCtrl" => keys.push(Keys::LeftCtrl as u32),
            "LeftShift" => keys.push(Keys::LeftShift as u32),
            "Ctrl" => keys.push(Keys::LeftCtrl as u32), // Assuming "Ctrl" refers to "LeftCtrl"
            "LeftMod" => keys.push(Keys::LeftMod as u32),
            "Alt" => keys.push(Keys::LeftAlt as u32), // Assuming "Alt" refers to "LeftAlt"
            "Space" => keys.push(Keys::Space as u32),
            "Enter" => keys.push(Keys::Enter as u32),
            "Backspace" => keys.push(Keys::Backspace as u32),
            "Tab" => keys.push(Keys::Tab as u32),
            "Up" => keys.push(Keys::Up as u32),
            "Down" => keys.push(Keys::Down as u32),
            "Left" => keys.push(Keys::Left as u32),
            "Right" => keys.push(Keys::Right as u32),
            "Insert" => keys.push(Keys::Insert as u32),
            "Delete" => keys.push(Keys::Delete as u32),
            "Home" => keys.push(Keys::Home as u32),
            "End" => keys.push(Keys::End as u32),
            "PageUp" => keys.push(Keys::PageUp as u32),
            "PageDown" => keys.push(Keys::PageDown as u32),
            "Comma"=> keys.push(Keys::Comma as u32),
            "Period"=> keys.push(Keys::Period as u32),
            "Slash"=> keys.push(Keys::Slash as u32),
            "RightCtrl"=> keys.push(Keys::RightCtrl as u32),
            "RightAlt"=> keys.push(Keys::RightAlt as u32),
            "RightShift"=> keys.push(Keys::RightShift as u32),
            "RightMod"=> keys.push(Keys::RightMod as u32),
            "LeftSquare"=> keys.push(Keys::LeftSquare as u32),
            "RightSquare"=> keys.push(Keys::RightSquare as u32),
            "SemiColon"=> keys.push(Keys::SemiColon as u32),
            "Quote"=> keys.push(Keys::Quote as u32),
            "BackSlash"=> keys.push(Keys::BackSlash as u32),
            "Dash"=> keys.push(Keys::Dash as u32),
            "Equal"=> keys.push(Keys::Equal as u32),
            _ => {}
        }
    }
    keys
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_parse_single_key() {
        let test_cases = [
            ("LeftShift", Keys::LeftShift as u32),
            ("LeftCtrl", Keys::LeftCtrl as u32),
            ("LeftMod", Keys::LeftMod as u32),
            ("LeftAlt", Keys::LeftAlt as u32),
            ("RightShift", Keys::RightShift as u32),
            ("RightCtrl", Keys::RightCtrl as u32),
            ("RightMod", Keys::RightMod as u32),
            ("RightAlt", Keys::RightAlt as u32),
            ("Space", Keys::Space as u32),
            ("Enter", Keys::Enter as u32),
            ("Backspace", Keys::Backspace as u32),
            ("Tab", Keys::Tab as u32),
            ("Up", Keys::Up as u32),
            ("Down", Keys::Down as u32),
            ("Left", Keys::Left as u32),
            ("Right", Keys::Right as u32),
            ("Insert", Keys::Insert as u32),
            ("Delete", Keys::Delete as u32),
            ("Home", Keys::Home as u32),
            ("End", Keys::End as u32),
            ("PageUp", Keys::PageUp as u32),
            ("PageDown", Keys::PageDown as u32),
            ("Comma", Keys::Comma as u32),
            ("Period", Keys::Period as u32),
            ("Slash", Keys::Slash as u32),
            ("LeftSquare", Keys::LeftSquare as u32),
            ("RightSquare", Keys::RightSquare as u32),
            ("SemiColon", Keys::SemiColon as u32),
            ("Quote", Keys::Quote as u32),
            ("BackSlash", Keys::BackSlash as u32),
            ("Dash", Keys::Dash as u32),
            ("Equal", Keys::Equal as u32),
            ("A", Keys::A as u32),
            ("B", Keys::B as u32),
            ("C", Keys::C as u32),
            ("D", Keys::D as u32),
            ("E", Keys::E as u32),
            ("F", Keys::F as u32),
            ("G", Keys::G as u32),
            ("H", Keys::H as u32),
            ("I", Keys::I as u32),
            ("J", Keys::J as u32),
            ("K", Keys::K as u32),
            ("L", Keys::L as u32),
            ("M", Keys::M as u32),
            ("N", Keys::N as u32),
            ("O", Keys::O as u32),
            ("P", Keys::P as u32),
            ("Q", Keys::Q as u32),
            ("R", Keys::R as u32),
            ("S", Keys::S as u32),
            ("T", Keys::T as u32),
            ("U", Keys::U as u32),
            ("V", Keys::V as u32),
            ("W", Keys::W as u32),
            ("X", Keys::X as u32),
            ("Y", Keys::Y as u32),
            ("Z", Keys::Z as u32),
            ("BackTick", Keys::BackTick as u32),
            ("0", Keys::Num0 as u32),
            ("1", Keys::Num1 as u32),
            ("2", Keys::Num2 as u32),
            ("3", Keys::Num3 as u32),
            ("4", Keys::Num4 as u32),
            ("5", Keys::Num5 as u32),
            ("6", Keys::Num6 as u32),
            ("7", Keys::Num7 as u32),
            ("8", Keys::Num8 as u32),
            ("9", Keys::Num9 as u32),
            ("F1", Keys::F1 as u32),
            ("F2", Keys::F2 as u32),
            ("F3", Keys::F3 as u32),
            ("F4", Keys::F4 as u32),
            ("F5", Keys::F5 as u32),
            ("F6", Keys::F6 as u32),
            ("F7", Keys::F7 as u32),
            ("F8", Keys::F8 as u32),
            ("F9", Keys::F9 as u32),
            ("F10", Keys::F10 as u32),
            ("F11", Keys::F11 as u32),
            ("F12", Keys::F12 as u32),
  
        ];

        for (input, expected_output) in test_cases {
            assert_eq!(parse_binding(input), vec![expected_output], "Failed for input: {}", input);
        }
    }
}